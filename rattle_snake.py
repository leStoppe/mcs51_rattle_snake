#lestoppe 2023-06-05 (rattle_snake.py)
# Use this script with 8051 assembly and ASXXXX assembler. This program will 
# check for common assembly issues and report errors. The goals are
#	1. Missing the # in an immediate constant. This will result in the instruction accessing memory instead.
#	2. using the wrong segment address in an instruction (bit address in a byte instruction, internal ram high used in direct mode for e.g.)
#	3. report code, ram space usage. Call depth (a bit hard)
#	4. Eventually generate a python script and kernel assembly tailored to the user assembly for interactive testing.
#
#	When linking use the following options (aslink -m -i -u -w) for compatibility

import re
import argparse
import os

def check_files_existance(input_file_list):
	for file in input_file_list:		
		if (not os.path.isfile (file)):
			print ("Error! File \'{0}\' not found".format(file))
			exit()


# Opens a single asm file (passed as arg) and checks for issue type #1 (refer above)
re_immediate_number = re.compile (r"^\s*(MOV|ADD|ADDC|SUBB|ANL|ORL|XRL|CJNE)\s+.+\,\s*(\d+)")
def lint_check_immediate_numbers (asm_file_name):
	# allowed numbers, plain (20), prefixed (0b, 0B, 0o, 0O, 0q, 0Q, 0d, 0D, 0h, 0H,0x,0X)
	fh_asm = open(asm_file_name, 'r')
	issue_list = []
	for counter, line in enumerate(fh_asm):
		line = line.upper()
		if (re_immediate_number.search(line)):
			#print ("Warning! {0} [{1}] numeral without # prefix. Is this intended to be an address?".format(asm_file_name, counter+1))
			issue_list.append([counter+1, line])
	print ("Linting [imm const check] {0} , found {1} issues".format (asm_file_name, len(issue_list) )  )
	if (len(issue_list) > 0):
		print ("These lines have numerals without a # prefix. Is this intended to be an address ?")
		for issues in issue_list:
			print ("\t[{0}] {1}".format(issues[0], issues[1]) )

	fh_asm.close()

# opens a map file that aslink generates to get the areas and their stats
# always have the following areas, even if they're empty. It helps to minimize unintentional mistakes related to memory access
# looks for specific areas :
#	VECTORS : holds the reset vectors
#	CODE	: the flash codesegment where all the code fits in
#	IRAML	: lower internal ram (0-7Fh). Can be accessed in direct/indirect modes. Hold the registers, the bit ram and scratch area
#	IRAMH	: upper internal ram (0x80 - 0xFFh). Can be accessed indirectly only. The same address range in direct mode accesses SFRs. Big risk of typo
#	BITRAM	: IRAML (20h to 30h) are bit accessible as 0h-7FH. Risk of using bit address in byte instruction.
#	XRAM	: internal xtended ram (varies with chip). Range starts from 0, so there is risk of using this in iram or code instructions.
#			Additionally there is also a risk of exceeding available memory.

re_match_areas = re.compile(r"^(VECTORS|CODE|IRAML|IRAMH|BITRAM|XRAM)\s+([0-9A-Fa-f]+)\s+([0-9A-Fa-f]+)")
def get_map_areas_size(map_file):
	fh_mapfile = open(map_file, 'r')
	area_list = []
	for line in fh_mapfile:
		match = re_match_areas.search(line)
		if (match):
			area_list.append( match.groups() )
	fh_mapfile.close()
	return area_list

# setup the argument parser, get the arguments and call respective functions
parser = argparse.ArgumentParser(
			prog='rattle_snake.py',
			description='A simple python linter for 8051 assembly. Works with ASXXXX assembler',
			epilog='------')

parser.add_argument('--map_file', metavar='map_file', type=str,
			action='store', nargs=1,
			help='output map file generated by aslink')
parser.add_argument('--asm_file', metavar='asm_file', type=str,
			action='store', nargs='+',
			help='input assembly file to be linted')

args = parser.parse_args()

#print (args.map_file)
#print (args.asm_file)
check_files_existance(args.map_file)
check_files_existance(args.asm_file)

print (get_map_areas_size(args.map_file[0])[0][0])
lint_check_immediate_numbers(args.asm_file[0])